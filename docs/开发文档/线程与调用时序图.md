# 线程与调用关系时序图（v1.9）

本文档展示应用在“启动 → 正常上传/重复询问/网络监控 → 停止”过程中的跨线程调用与阻塞关系。图中仅标注关键路径与超时点。

## 时序图

```mermaid
sequenceDiagram
    autonumber
    participant UI as MainWindow/UI线程
    participant QT as worker_thread(Qt线程)
    participant W as UploadWorker 对象
    participant U as 上传主线程(_thread)
    participant N as 网络监控线程(_net_thread)
    participant A as 归档线程(_archive_thread)
    participant FE as 文件操作线程池(_executor)
    participant NE as 网络检查线程池(_net_executor)
    participant LE as 日志线程池(_log_executor)

    %% 启动
    UI->>QT: 创建 QThread 并启动
    QT->>W: started → 调用 start()
    W->>U: 启动 _run() 原生线程
    W->>N: 启动 _network_monitor_loop 原生线程

    %% 正常循环（上传主线程）
    rect rgb(245, 248, 255)
      U->>U: 扫描源目录（_get_image_files）
      U->>FE: _safe_path_operation(os.walk / exists, timeout=5s/2s)
      FE-->>U: 结果或默认值（超时兜底）

      loop 每个文件
        U->>U: 快速网络状态检查（被动使用缓存/短超时）
        alt 目标文件存在且未启用去重
          U->>UI: log("已存在，跳过")
          U->>UI: stats/file_progress(100%)
          U->>A: 归档队列 enqueue(src→bkp)
        else 启用去重
          U->>U: 计算文件哈希
          U->>U: 在目标侧查重（按哈希）
          alt 发现重复 且 策略==ask
            U-->>UI: ask_user_duplicate(payload)
            note over U: 阻塞等待 evt.wait(timeout=120s)
            UI->>UI: 弹出 QDialog（跳过/重命名/覆盖 + 应用于后续）
            UI-->>U: 回填 payload.result + evt.set()
            opt 选择“应用于后续”
              U->>U: 缓存选择（后续同类不再弹窗）
            end
          end

          alt 选择“跳过”
            U->>UI: log/stats/file_progress(100%)
            U->>A: 归档队列 enqueue(src→bkp)
          else 选择“重命名”或“覆盖”或“无重复”
            U->>FE: _safe_path_operation(os.makedirs, timeout=3s)
            FE-->>U: 结果（超时报错）
            alt 大文件(>10MB)
              U->>U: _copy_with_progress（分片更新 file_progress）
            else 小文件
              U->>FE: _safe_path_operation(shutil.copy2, timeout=10s)
              FE-->>U: 结果（超时报错）
            end
            U->>UI: log/stats/file_progress(100%)
            U->>A: 归档队列 enqueue(src→bkp)
          end
        end
      end
    end

    %% 归档线程
    rect rgb(255, 250, 240)
      par 归档独立执行
        A->>A: archive_queue.get(timeout=1s)
        alt 有任务
          A->>A: os.makedirs(备份目录, exist_ok=True)
          A->>A: shutil.move(src, bkp)
          A-->>UI: log("已归档")
        else 超时/空队列
          A->>A: 循环继续（不阻塞他人）
        end
      and UI日志落盘
        UI->>LE: 异步写日志/更新磁盘信息
      end
    end

    %% 网络监控线程
    rect rgb(240, 255, 245)
      loop 自适应周期（正常放缓/异常加速≈1s）
        N->>NE: _safe_net_check(ping/exists, timeout≈0.3–1.5s)
        NE-->>N: 结果（可达/不可达）
        N-->>UI: network_status(good/unstable/disconnected)
        note over U,N: 上传主线程在循环中被动读取/响应网络状态
      end
    end

    %% 停止
    UI->>W: stop()
    W->>FE: shutdown(wait=False, cancel_futures=True)
    W->>NE: shutdown(wait=False, cancel_futures=True)
    W-->>U: 置 _running=False，循环自然退出
    W-->>N: 置 _running=False，循环自然退出
    W-->>A: 置 _running=False，循环自然退出
    W-->>UI: status("stopped"), finished()
```

## 说明与原则

- UI 线程仅做界面与信号处理；所有耗时 I/O（日志、磁盘查询）交给 `LE` 异步执行。
- 上传主线程与网络监控线程的所有可能“卡住”的系统调用，都经由线程池封装并设置明确超时（2–10s），确保最坏只阻塞各自线程，不影响 UI。
- 重复文件“询问模式”是唯一跨线程的“设计性等待”：上传主线程等待 UI 的选择，超时 120s 后默认按“跳过”，并支持“应用于后续”缓存选择以消除后续弹窗。
- 归档在独立线程进行，不阻塞上传；队列 get 使用 1s 超时避免死等。
- 停止流程使用线程池的非阻塞 shutdown（cancel_futures），各线程按 `_running=False` 自行收尾并发信号给 UI。

## 关联代码入口

- 启动：`MainWindow._on_start` → `worker_thread` → `UploadWorker.start`
- 上传主循环：`UploadWorker._run`
- 网络监控：`UploadWorker._network_monitor_loop`
- 安全操作封装：`UploadWorker._safe_path_operation`、`UploadWorker._safe_net_check`
- 归档：`UploadWorker._archive_worker`
- 停止：`UploadWorker.stop`、`MainWindow._on_stop`
