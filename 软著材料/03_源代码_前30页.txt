======================================================================
  å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶ V3.1.0
  æºä»£ç æ–‡æ¡£ï¼ˆå‰ 30 é¡µï¼‰
======================================================================
  ç”Ÿæˆæ—¥æœŸ: 2025å¹´11æœˆ27æ—¥
  æ¯é¡µè¡Œæ•°: 50 è¡Œ
======================================================================

å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                   ç¬¬ 1 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
       # ============================================================
       # æ–‡ä»¶: pyqt_app.py
       # ============================================================
    1  # -*- coding: utf-8 -*-
    2  """
    3  PyQtç‰ˆ å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·ï¼ˆMVPï¼‰
    4  - ä¸‰æ®µå¸ƒå±€ï¼šå·¦ï¼ˆè¾“å…¥è®¾ç½®ï¼‰ã€å³ï¼ˆæ§åˆ¶+çŠ¶æ€ï¼‰ã€åº•éƒ¨ï¼ˆæ—¥å¿—ï¼‰
    5  - æ¸å˜è¿›åº¦æ¡ + ç™¾åˆ†æ¯”/æ–‡ä»¶å/å‰©ä½™æ—¶é—´
    6  - çŠ¶æ€èƒ¶å›Š + å›¾æ ‡
    7  - æ—¥å¿—è‡ªåŠ¨æ»šåŠ¨é”
    8  - è¾…åŠ©æ“ä½œåœ¨â€œæ›´å¤šâ€èœå•
    9  - ç®€æ˜“åå°çº¿ç¨‹æ‰§è¡Œä¸Šä¼ ä¸å½’æ¡£ï¼ˆä¸ä¾èµ– Tk å˜é‡ï¼‰
   10  
   11  åç»­å¯é€æ­¥æ›¿æ¢ Tk ç‰ˆå…¥å£ã€‚
   12  """
   13  import os
   14  import sys
   15  import json
   16  import time
   17  import shutil
   18  import threading
   19  import datetime
   20  import queue
   21  import winreg
   22  import hashlib
   23  from pathlib import Path
   24  from typing import List, Tuple, Optional, Any, TYPE_CHECKING
   25  from concurrent.futures import ThreadPoolExecutor, TimeoutError as FuturesTimeoutError
   26  
   27  # v2.0 æ–°å¢ï¼šå¯¼å…¥ FTP åè®®æ¨¡å—
   28  try:
   29      from src.protocols.ftp import FTPProtocolManager, FTPServerManager, FTPClientUploader
   30      FTP_AVAILABLE = True
   31  except ImportError:
   32      FTP_AVAILABLE = False
   33      print("è­¦å‘Š: FTP æ¨¡å—å¯¼å…¥å¤±è´¥ï¼ŒFTP åŠŸèƒ½ä¸å¯ç”¨")
   34  
   35  # v2.3.1 æ–°å¢ï¼šå¯¼å…¥æ¨¡å—åŒ–ç»„ä»¶ï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
   36  try:
   37      from src.ui.widgets import Toast as ModularToast
   38      from src.ui.widgets import ChipWidget as ModularChipWidget
   39      from src.ui.widgets import CollapsibleBox as ModularCollapsibleBox
   40      from src.ui.widgets import DiskCleanupDialog as ModularDiskCleanupDialog
   41      from src.workers.upload_worker import UploadWorker as ModularUploadWorker
   42      MODULAR_COMPONENTS_AVAILABLE = True
   43  except ImportError:
   44      MODULAR_COMPONENTS_AVAILABLE = False
   45      print("æç¤º: æ¨¡å—åŒ–ç»„ä»¶æœªå¯ç”¨ï¼Œä½¿ç”¨å†…ç½®ç»„ä»¶")
   46  
   47  # v2.3.0 æ–°å¢ï¼šå¯¼å…¥ç±»å‹å®‰å…¨çš„ Qt æšä¸¾è®¿é—®å™¨

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                   ç¬¬ 2 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
   48  from qt_types import MessageBoxIcon, MessageBoxButton, TrayIconType, EventType
   49  
   50  # ????????????
   51  from src.ui.main_window import MainWindow
   52  
   53  # è¿è¡Œæ—¶å¯¼å…¥ Qt åº“
   54  try:
   55      from PySide6 import QtCore, QtGui, QtWidgets
   56      from PySide6.QtNetwork import QLocalServer, QLocalSocket
   57      Signal = QtCore.Signal  # PySide6 ä¿¡å·
   58      QT_LIB = 'PySide6'
   59  except ImportError:
   60      try:
   61          from PyQt5 import QtCore, QtGui, QtWidgets  # type: ignore[import-not-found]
   62          from PyQt5.QtNetwork import QLocalServer, QLocalSocket  # type: ignore[import-not-found]
   63          Signal = QtCore.pyqtSignal  # PyQt5 ä¿¡å·
   64          QT_LIB = 'PyQt5'
   65      except ImportError:
   66          raise ImportError("Neither PySide6 nor PyQt5 is installed. Please install one of them.")
   67  
   68  # ç±»å‹æ£€æŸ¥æ—¶çš„é¢å¤–å¯¼å…¥ï¼ˆé¿å… Pylance ç±»ç»§æ‰¿è¯¯æŠ¥ï¼‰
   69  if TYPE_CHECKING:
   70      # ç¡®ä¿ç±»å‹æ£€æŸ¥å™¨èƒ½è¯†åˆ« Qt ç±»ä½œä¸ºæœ‰æ•ˆåŸºç±»
   71      # è¿™ä¸ä¼šå½±å“è¿è¡Œæ—¶ï¼Œåªæ˜¯å¸®åŠ©é™æ€åˆ†æå·¥å…·
   72      pass
   73  
   74  # ç»Ÿä¸€è®¿é—® Qt æšä¸¾ï¼ˆå…¼å®¹ Qt6 çš„å¼ºç±»å‹æšä¸¾å‘½åï¼‰
   75  QtEnum = QtCore.Qt
   76  
   77  # v2.2.0 Qtæšä¸¾å…¼å®¹æ€§è¾…åŠ©å‡½æ•°ï¼ˆæ¶ˆé™¤Pylanceè­¦å‘Šï¼‰
   78  def get_qt_enum(enum_class, attr_name: str, fallback_value: int):
   79      """å®‰å…¨è·å–Qtæšä¸¾å€¼ï¼Œå…¼å®¹PySide6/PyQt5"""
   80      try:
   81          return getattr(enum_class, attr_name, fallback_value)
   82      except AttributeError:
   83          return fallback_value
   84  
   85  APP_TITLE = "å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…· v3.0.1"
   86  APP_VERSION = "3.0.2"
   87  
   88  
   89  def get_app_dir() -> Path:
   90      """è·å–åº”ç”¨ç¨‹åºæ•°æ®ç›®å½•ï¼ˆç”¨äºé…ç½®å’Œæ—¥å¿—ç­‰å¯å†™æ–‡ä»¶ï¼‰
   91      - å¼€å‘ç¯å¢ƒï¼šè¿”å›è„šæœ¬æ‰€åœ¨ç›®å½•
   92      - æ‰“åŒ…åï¼šè¿”å› exe æ‰€åœ¨ç›®å½•ï¼ˆç”¨æˆ·å¯å†™ï¼‰
   93      """
   94      if getattr(sys, 'frozen', False):
   95          # PyInstaller æ‰“åŒ…åï¼Œè¿”å› exe æ‰€åœ¨ç›®å½•
   96          return Path(sys.executable).parent
   97      return Path(__file__).parent

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                   ç¬¬ 3 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
   98  
   99  
  100  def get_resource_path(relative_path: str) -> Path:
  101      """è·å–èµ„æºæ–‡ä»¶çš„ç»å¯¹è·¯å¾„ï¼ˆæ”¯æŒæ‰“åŒ…ï¼‰
  102      
  103      ç”¨äºè¯»å–åªè¯»èµ„æºæ–‡ä»¶ï¼Œå¦‚ Logoã€é»˜è®¤é…ç½®ç­‰
  104      
  105      Args:
  106          relative_path: ç›¸å¯¹äºèµ„æºç›®å½•çš„è·¯å¾„ï¼Œå¦‚ 'assets/logo.png'
  107      
  108      Returns:
  109          èµ„æºæ–‡ä»¶çš„ç»å¯¹è·¯å¾„
  110      """
  111      if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
  112          # æ‰“åŒ…åï¼Œèµ„æºæ–‡ä»¶åœ¨ _internal ç›®å½•ï¼ˆsys._MEIPASSï¼‰
  113          # ä½¿ç”¨ getattr é¿å…ç±»å‹æ£€æŸ¥é”™è¯¯ï¼ˆ_MEIPASS æ˜¯è¿è¡Œæ—¶åŠ¨æ€å±æ€§ï¼‰
  114          base_path = Path(getattr(sys, '_MEIPASS'))
  115      else:
  116          # å¼€å‘ç¯å¢ƒï¼Œèµ„æºæ–‡ä»¶åœ¨è„šæœ¬ç›®å½•
  117          base_path = Path(__file__).parent
  118      return base_path / relative_path
  119  
  120  
  121  class Toast(QtWidgets.QWidget):  # type: ignore[misc]
  122      """Toast é€šçŸ¥ç»„ä»¶
  123      
  124      Note: ä½¿ç”¨ type: ignore[misc] æ˜¯å› ä¸º Qt æ¨¡å—åœ¨ try-except ä¸­åŠ¨æ€å¯¼å…¥ï¼Œ
  125      Pylance æ— æ³•åœ¨é™æ€åˆ†ææ—¶ç¡®å®šåŸºç±»æœ‰æ•ˆæ€§ï¼Œä½†è¿è¡Œæ—¶å®Œå…¨æ­£ç¡®ã€‚
  126      """
  127      def __init__(self, parent: QtWidgets.QWidget, message: str, kind: str = 'info', duration_ms: int = 2500):
  128          super().__init__(parent)
  129          wt = getattr(QtEnum, 'WindowType', QtEnum)
  130          wa = getattr(QtEnum, 'WidgetAttribute', QtEnum)
  131          self.setWindowFlags(
  132              getattr(wt, 'FramelessWindowHint')
  133              | getattr(wt, 'Tool')
  134              | getattr(wt, 'WindowStaysOnTopHint')
  135          )
  136          self.setAttribute(getattr(wa, 'WA_TranslucentBackground'))
  137          colors = {
  138              'info':    ("#E0F2FE", "#039CA1"),
  139              'success': ("#DCFCE7", "#166534"),
  140              'warning': ("#FEF9C3", "#A16207"),
  141              'danger':  ("#FEE2E2", "#B91C1C"),
  142          }
  143          bg, fg = colors.get(kind, colors['info'])
  144          layout = QtWidgets.QHBoxLayout(self)
  145          frame = QtWidgets.QFrame(self)
  146          frame.setStyleSheet(f"QFrame{{background:{bg}; border:1px solid rgba(0,0,0,0.06); border-radius:8px;}}")
  147          inner = QtWidgets.QHBoxLayout(frame)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                   ç¬¬ 4 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  148          label = QtWidgets.QLabel(message)
  149          label.setStyleSheet(f"color:{fg}; padding:8px 12px; font-size:11pt;")
  150          inner.addWidget(label)
  151          layout.addWidget(frame)
  152          self.adjustSize()
  153          self._timer = QtCore.QTimer(self)
  154          self._timer.setSingleShot(True)
  155          self._timer.timeout.connect(self.close)
  156          self._timer.start(duration_ms)
  157  
  158      def showEvent(self, e: QtGui.QShowEvent) -> None:
  159          if self.parent():
  160              p = self.parent()
  161              geo = p.geometry()
  162              self.adjustSize()
  163              x = geo.x() + geo.width() - self.width() - 16
  164              y = geo.y() + 80
  165              self.move(x, y)
  166          return super().showEvent(e)
  167  
  168  
  169  class UploadWorker(QtCore.QObject):  # type: ignore[misc]
  170      # signals
  171      log = Signal(str)
  172      stats = Signal(int, int, int, str)   # uploaded, failed, skipped, rate
  173      progress = Signal(int, int, str)     # current, total, filename
  174      file_progress = Signal(str, int)     # current_file, progress_percent
  175      network_status = Signal(str)         # 'good'|'unstable'|'disconnected'
  176      finished = Signal()
  177      status = Signal(str)                 # 'running'|'paused'|'stopped'
  178      ask_user_duplicate = Signal(object)  # payload dict: {'file': str, 'duplicate': str, 'event': threading.Event, 'result': dict}
  179      upload_error = Signal(str, str)      # v2.2.0 æ–°å¢ï¼šfilename, error_message
  180      disk_warning = Signal(float, float, int)  # v2.2.0 æ–°å¢ï¼štarget_percent, backup_percent, threshold
  181  
  182      def __init__(self, source: str, target: str, backup: str,
  183                   interval: int, mode: str, disk_threshold_percent: int, retry_count: int,
  184                   filters: List[str], app_dir: Path,
  185                   enable_deduplication: bool = False, hash_algorithm: str = 'md5',
  186                   duplicate_strategy: str = 'ask',
  187                   network_check_interval: int = 10, network_auto_pause: bool = True,
  188                   network_auto_resume: bool = True,
  189                   enable_auto_delete: bool = False, auto_delete_folder: str = '',
  190                   auto_delete_threshold: int = 80, auto_delete_keep_days: int = 10,
  191                   auto_delete_check_interval: int = 300,
  192                   # v2.0 æ–°å¢ï¼šåè®®ç›¸å…³å‚æ•°
  193                   upload_protocol: str = 'smb',
  194                   ftp_client_config: Optional[dict] = None,
  195                   # v2.2.0 æ–°å¢ï¼šå¤‡ä»½å¯ç”¨çŠ¶æ€
  196                   enable_backup: bool = True,
  197                   # v2.3.0 æ–°å¢ï¼šé€Ÿç‡é™åˆ¶å‚æ•°

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                   ç¬¬ 5 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  198                   limit_upload_rate: bool = False,
  199                   max_upload_rate_mbps: float = 10.0):
  200          super().__init__()
  201          self.source = source
  202          self.target = target
  203          self.backup = backup
  204          # v2.2.0 æ–°å¢ï¼šä¿å­˜å¤‡ä»½å¯ç”¨çŠ¶æ€
  205          self.enable_backup = enable_backup
  206          # v2.3.0 æ–°å¢ï¼šé€Ÿç‡é™åˆ¶é…ç½®
  207          self.limit_upload_rate = limit_upload_rate
  208          self.max_upload_rate_bytes = int(max_upload_rate_mbps * 1024 * 1024) if limit_upload_rate else 0
  209          self.interval = interval
  210          self.mode = mode
  211          self.disk_threshold_percent = max(5, disk_threshold_percent)
  212          self.retry_count = retry_count
  213          self.filters = [ext.lower() for ext in filters]
  214          self.app_dir = app_dir
  215          # å»é‡é…ç½®
  216          self.enable_deduplication = enable_deduplication
  217          self.hash_algorithm = hash_algorithm.lower()
  218          self.duplicate_strategy = duplicate_strategy
  219          # ç½‘ç»œç›‘æ§é…ç½®
  220          self.network_check_interval = network_check_interval
  221          self.network_auto_pause = network_auto_pause
  222          self.network_auto_resume = network_auto_resume
  223          # è‡ªåŠ¨åˆ é™¤é…ç½®
  224          self.enable_auto_delete = enable_auto_delete
  225          self.auto_delete_folder = auto_delete_folder
  226          self.auto_delete_threshold = auto_delete_threshold
  227          self.auto_delete_keep_days = auto_delete_keep_days
  228          self.auto_delete_check_interval = auto_delete_check_interval
  229          # v2.0 æ–°å¢ï¼šåè®®é…ç½®
  230          self.upload_protocol = upload_protocol  # 'smb', 'ftp_client', 'both'
  231          self.ftp_client_config = ftp_client_config or {}
  232          self.ftp_client = None  # FTPå®¢æˆ·ç«¯å®ä¾‹
  233          
  234          self._running = False
  235          self._paused = False
  236          self._thread = None
  237          self._archive_thread = None
  238          # stats
  239          self.uploaded = 0
  240          self.failed = 0
  241          self.skipped = 0
  242          self.rate = "0 MB/s"
  243          self.total_files = 0
  244          self.current = 0
  245          self.start_time = None
  246          # å½“å‰æ–‡ä»¶ä¿¡æ¯
  247          self.current_file_name = ""

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                   ç¬¬ 6 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  248          self.current_file_size = 0
  249          self.current_file_uploaded = 0
  250          # å¤±è´¥é‡è¯•é˜Ÿåˆ—
  251          self.retry_queue = {}  # {file_path: retry_count}
  252          # å½’æ¡£é˜Ÿåˆ—
  253          self.archive_queue = queue.Queue()
  254          # ç½‘ç»œè¿æ¥çŠ¶æ€
  255          self.network_retry_count = 0
  256          self.network_auto_retry = True
  257          self.last_network_check = 0
  258          self.current_network_status = 'unknown'  # good, unstable, disconnected, unknown
  259          self.network_pause_by_auto = False  # æ˜¯å¦ç”±ç½‘ç»œä¸­æ–­è‡ªåŠ¨æš‚åœ
  260          self._last_space_warn = 0.0
  261          # å¤±è´¥æ—¥å¿—æ–‡ä»¶
  262          self.failed_log_path = self.app_dir / "failed_files.log"
  263          # çº¿ç¨‹æ± ç”¨äºæ‰§è¡Œå¯èƒ½é˜»å¡çš„æ–‡ä»¶æ“ä½œ
  264          self._executor = ThreadPoolExecutor(max_workers=3, thread_name_prefix="FileOp")
  265          # ç‹¬ç«‹çº¿ç¨‹æ± ç”¨äºç½‘ç»œå¯è¾¾æ€§å¿«é€Ÿæ£€æµ‹ï¼Œé¿å…ä¸æ–‡ä»¶æ“ä½œäº’ç›¸é˜»å¡
  266          self._net_executor = ThreadPoolExecutor(max_workers=1, thread_name_prefix="NetChk")
  267          # è¯¢é—®æ¨¡å¼çš„å…¨å±€é€‰æ‹©ï¼ˆå¯ç”±ç”¨æˆ·é€‰æ‹©â€œåº”ç”¨äºåç»­â€ï¼‰
  268          self._duplicate_ask_choice = None  # None| 'skip'|'rename'|'overwrite'
  269  
  270      def start(self):
  271          if self._running:
  272              return
  273          self._running = True
  274          self._paused = False
  275          self._thread = threading.Thread(target=self._run, daemon=True)
  276          self._thread.start()
  277          # å¯åŠ¨ç½‘ç»œç›‘æ§çº¿ç¨‹ï¼ˆç‹¬ç«‹äºä¸Šä¼ ä¸»å¾ªç¯ï¼‰
  278          self._net_running = True
  279          self._net_thread = threading.Thread(target=self._network_monitor_loop, daemon=True)
  280          self._net_thread.start()
  281          self.status.emit('running')
  282  
  283      def pause(self):
  284          if not self._running:
  285              return
  286          self._paused = True
  287          self.status.emit('paused')
  288  
  289      def resume(self):
  290          if not self._running:
  291              return
  292          self._paused = False
  293          self.status.emit('running')
  294  
  295      def stop(self):
  296          self._running = False
  297          self._paused = False

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                   ç¬¬ 7 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  298          
  299          # v2.0 æ–°å¢ï¼šå…³é—­FTPå®¢æˆ·ç«¯è¿æ¥
  300          if self.ftp_client:
  301              try:
  302                  self.ftp_client.disconnect()
  303                  self.ftp_client = None
  304              except Exception as e:
  305                  pass  # å¿½ç•¥æ–­å¼€è¿æ¥é”™è¯¯
  306          
  307          # å…³é—­çº¿ç¨‹æ± 
  308          try:
  309              self._executor.shutdown(wait=False, cancel_futures=True)
  310          except:
  311              pass
  312          # åœæ­¢ç½‘ç»œç›‘æ§çº¿ç¨‹
  313          self._net_running = False
  314          # å…³é—­ç½‘ç»œæ£€æµ‹çº¿ç¨‹æ± 
  315          try:
  316              self._net_executor.shutdown(wait=False, cancel_futures=True)
  317          except:
  318              pass
  319          self.status.emit('stopped')
  320  
  321      def _network_monitor_loop(self):
  322          """ç‹¬ç«‹ç½‘ç»œç›‘æ§çº¿ç¨‹ï¼Œå‘¨æœŸæ€§æ£€æµ‹å¹¶å‘å°„çŠ¶æ€ä¿¡å·ï¼Œé¿å…ä¸Šä¼ å¾ªç¯é˜»å¡å¯¼è‡´çŠ¶æ€ä¸æ›´æ–°"""
  323          last_status = 'unknown'
  324          while getattr(self, '_net_running', False):
  325              # è½»é‡æ¢æµ‹
  326              try:
  327                  # ç›®æ ‡ä¼˜å…ˆ
  328                  target_ok = self._safe_net_check(self.target, timeout=0.3, default=False)
  329                  if target_ok:
  330                      status = 'good'
  331                  else:
  332                      backup_ok = self._safe_net_check(self.backup, timeout=0.3, default=False)
  333                      status = 'unstable' if backup_ok else 'disconnected'
  334              except Exception:
  335                  status = 'disconnected'
  336  
  337              if status != last_status:
  338                  # æ—¥å¿—ä»…åœ¨çŠ¶æ€å˜åŒ–æ—¶è¾“å‡º
  339                  if status == 'good' and last_status in ('unstable', 'disconnected'):
  340                      self.log.emit('âœ… ç½‘ç»œå·²æ¢å¤æ­£å¸¸')
  341                  elif status == 'unstable':
  342                      self.log.emit('âš ï¸ ç½‘ç»œä¸ç¨³å®šï¼šç›®æ ‡ä¸å¯è¾¾ï¼Œä½†å¤‡ä»½å¯è¾¾')
  343                  elif status == 'disconnected':
  344                      self.log.emit('âŒ ç½‘ç»œè¿æ¥ä¸­æ–­')
  345                  self.network_status.emit(status)
  346                  self.current_network_status = status
  347                  last_status = status

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                   ç¬¬ 8 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  348  
  349                  # è‡ªåŠ¨æš‚åœ/æ¢å¤
  350                  if status == 'disconnected' and self.network_auto_pause and not self._paused:
  351                      self.network_pause_by_auto = True
  352                      self.pause()
  353                  if status == 'good' and self.network_auto_resume and self.network_pause_by_auto:
  354                      self.network_pause_by_auto = False
  355                      self.resume()
  356  
  357              # æ–­å¼€çŠ¶æ€ä¸‹æ¯3æ¬¡è¾“å‡ºä¸€æ¬¡å¿ƒè·³
  358              if status == 'disconnected':
  359                  self.network_retry_count += 1
  360                  if self.network_retry_count % 3 == 0:
  361                      self.log.emit(f"ğŸ”Œ ç½‘ç»œä»æœªæ¢å¤ (ç¬¬{self.network_retry_count}æ¬¡æ£€æµ‹)")
  362              else:
  363                  self.network_retry_count = 0
  364  
  365              # å®šæ—¶å‘é€ä¸€æ¬¡ç»Ÿè®¡å¿ƒè·³ï¼Œä¿è¯UIåœ¨ç½‘ç»œæ¢å¤/æš‚åœæœŸé—´ä¹Ÿèƒ½æŒç»­åˆ·æ–°
  366              try:
  367                  self.stats.emit(self.uploaded, self.failed, self.skipped, self.rate)
  368              except Exception:
  369                  pass
  370  
  371              # è‡ªé€‚åº”é—´éš”ï¼šå¼‚å¸¸æ—¶æ›´å¿«æ¢æµ‹ï¼Œæ­£å¸¸æ—¶ä½¿ç”¨ç”¨æˆ·è®¾ç½®
  372              interval = 1 if status in ('unstable', 'disconnected') else max(1, int(self.network_check_interval))
  373              time.sleep(interval)
  374  
  375      def _safe_net_check(self, path: str, timeout: float = 1.5, default=False) -> bool:
  376          """åœ¨ç‹¬ç«‹çš„ç½‘ç»œæ£€æµ‹çº¿ç¨‹æ± ä¸­æ£€æŸ¥è·¯å¾„å¯è¾¾æ€§ã€‚
  377          ä¼˜å…ˆå¯¹ç½‘ç»œè·¯å¾„ï¼ˆUNC/æ˜ å°„ç›˜ï¼‰åšå¿«é€Ÿ ping ä¸»æœºï¼Œé¿å… os.path.exists å¡ä½ï¼›
  378          æœ¬åœ°è·¯å¾„åˆ™ä»¥ exists ä¸ºå‡†ï¼ˆçº¿ç¨‹æ± +è¶…æ—¶ï¼‰ã€‚"""
  379          def is_unc(p: str) -> bool:
  380              return isinstance(p, str) and p.startswith('\\\\')
  381  
  382          def get_drive_root(p: str) -> str:
  383              drive, _ = os.path.splitdrive(p)
  384              return drive + '\\' if drive else ''
  385  
  386          def is_mapped_drive(p: str) -> bool:
  387              try:
  388                  root = get_drive_root(p)
  389                  if not root:
  390                      return False
  391                  import ctypes
  392                  DRIVE_REMOTE = 4
  393                  GetDriveTypeW = ctypes.windll.kernel32.GetDriveTypeW
  394                  GetDriveTypeW.argtypes = [ctypes.c_wchar_p]
  395                  GetDriveTypeW.restype = ctypes.c_uint
  396                  dtype = GetDriveTypeW(root)
  397                  return dtype == DRIVE_REMOTE

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                   ç¬¬ 9 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  398              except Exception:
  399                  return False
  400  
  401          def mapped_to_unc(p: str) -> str:
  402              """å°†æ˜ å°„ç›˜è·¯å¾„è½¬æ¢ä¸º UNCï¼ˆæœ€ä½³åŠªåŠ›ï¼‰ã€‚"""
  403              try:
  404                  import ctypes
  405                  from ctypes import wintypes
  406                  # WNetGetConnectionW è·å–æ˜ å°„ç›˜å¯¹åº”çš„ UNC å‰ç¼€
  407                  WNetGetConnectionW = ctypes.windll.mpr.WNetGetConnectionW
  408                  WNetGetConnectionW.argtypes = [wintypes.LPCWSTR, wintypes.LPWSTR, ctypes.POINTER(wintypes.DWORD)]
  409                  WNetGetConnectionW.restype = wintypes.DWORD
  410                  drive, tail = os.path.splitdrive(p)
  411                  if not drive:
  412                      return ''
  413                  # ç¼“å†²åŒº
  414                  buf_len = wintypes.DWORD(1024)
  415                  buf = ctypes.create_unicode_buffer(1024)
  416                  rc = WNetGetConnectionW(drive + '\\', buf, ctypes.byref(buf_len))
  417                  if rc == 0:
  418                      unc_prefix = buf.value  # ä¾‹å¦‚ \\server\share
  419                      # æ‹¼å‡ºå®Œæ•´ UNC è·¯å¾„
  420                      rel = p[len(drive):].lstrip('\\/')
  421                      return os.path.join(unc_prefix, rel).replace('/', '\\')
  422                  return ''
  423              except Exception:
  424                  return ''
  425  
  426          def extract_host_from_unc(unc: str) -> str:
  427              try:
  428                  # UNC: \\server\share\...
  429                  parts = unc.split('\\')
  430                  # ['', '', 'server', 'share', ...]
  431                  return parts[2] if len(parts) > 2 else ''
  432              except Exception:
  433                  return ''
  434  
  435          def ping_host(host: str, ms: int) -> bool:
  436              try:
  437                  import subprocess
  438                  # -n 1: ä¸€æ¬¡å›æ˜¾ï¼›-w ms: è¶…æ—¶æ¯«ç§’
  439                  completed = subprocess.run(['ping', '-n', '1', '-w', str(ms), host],
  440                                             stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
  441                                             timeout=max(0.2, ms/1000.0 + 0.5))
  442                  return completed.returncode == 0
  443              except Exception:
  444                  return False
  445  
  446          try:
  447              if not path:

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 10 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  448                  return bool(default)
  449              # UNC ç›´æ¥ ping ä¸»æœº
  450              if is_unc(path):
  451                  host = extract_host_from_unc(path)
  452                  if host:
  453                      return ping_host(host, int(timeout*1000))
  454                  return bool(default)
  455              # æ˜ å°„ç›˜ï¼šè½¬æ¢ä¸º UNC å† ping
  456              if is_mapped_drive(path):
  457                  unc = mapped_to_unc(path)
  458                  host = extract_host_from_unc(unc) if unc else ''
  459                  if host:
  460                      return ping_host(host, int(timeout*1000))
  461                  # å›é€€ existsï¼ˆçº¿ç¨‹æ± +è¶…æ—¶ï¼‰
  462                  future = self._net_executor.submit(os.path.exists, path)
  463                  return bool(future.result(timeout=timeout))
  464              # æœ¬åœ°è·¯å¾„ï¼šç›´æ¥ existsï¼ˆçº¿ç¨‹æ± +è¶…æ—¶ï¼‰
  465              future = self._net_executor.submit(os.path.exists, path)
  466              return bool(future.result(timeout=timeout))
  467          except Exception:
  468              return bool(default)
  469  
  470      # helpers
  471      def _safe_path_operation(self, func, *args, timeout: float = 3.0, default=None):
  472          """
  473          å®‰å…¨æ‰§è¡Œæ–‡ä»¶ç³»ç»Ÿæ“ä½œï¼Œä½¿ç”¨çº¿ç¨‹æ± å¸¦è¶…æ—¶æœºåˆ¶é˜²æ­¢é˜»å¡
  474          func: è¦æ‰§è¡Œçš„å‡½æ•°
  475          args: å‡½æ•°å‚æ•°
  476          timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
  477          default: è¶…æ—¶æˆ–å¼‚å¸¸æ—¶çš„é»˜è®¤è¿”å›å€¼
  478          """
  479          try:
  480              # æäº¤ä»»åŠ¡åˆ°çº¿ç¨‹æ± 
  481              future = self._executor.submit(func, *args)
  482              # ç­‰å¾…ç»“æœï¼Œå¸¦è¶…æ—¶
  483              result = future.result(timeout=timeout)
  484              return result
  485          except FuturesTimeoutError:
  486              # è¶…æ—¶ - ç¡®ä¿æ—¥å¿—ä¿¡å·èƒ½å‘é€
  487              try:
  488                  self.log.emit(f"â±ï¸ æ–‡ä»¶æ“ä½œè¶…æ—¶ï¼ˆ{timeout}ç§’ï¼‰ï¼Œå¯èƒ½ç½‘ç»œä¸­æ–­")
  489              except:
  490                  pass
  491              return default
  492          except Exception as e:
  493              # å…¶ä»–å¼‚å¸¸
  494              try:
  495                  self.log.emit(f"âš ï¸ æ–‡ä»¶æ“ä½œå¼‚å¸¸: {str(e)[:50]}")
  496              except:
  497                  pass

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 11 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  498              return default
  499      
  500      def _check_network_connection(self) -> str:
  501          """
  502          å¢å¼ºçš„ç½‘ç»œè¿æ¥æ£€æŸ¥ï¼ˆæ ¹æ®é…ç½®é—´éš”æ£€æŸ¥ï¼Œä½¿ç”¨è¶…æ—¶æœºåˆ¶é˜²æ­¢é˜»å¡ï¼‰
  503          è¿”å›ï¼š'good' | 'unstable' | 'disconnected'
  504          """
  505          # å½“ç‹¬ç«‹ç½‘ç»œç›‘æ§çº¿ç¨‹å·²è¿è¡Œæ—¶ï¼Œè¿™é‡Œä»…åšâ€œè¢«åŠ¨â€æ›´æ–°ï¼Œé¿å…é‡å¤æ—¥å¿—ä¸ä¿¡å·
  506          if getattr(self, '_net_running', False):
  507              now = time.time()
  508              if now - self.last_network_check < self.network_check_interval:
  509                  return self.current_network_status
  510              # è½»é‡æ¢æµ‹ï¼Œä»…æ›´æ–°ç¼“å­˜ï¼Œä¸å‘å°„ç½‘ç»œä¿¡å·ã€ä¸è¾“å‡ºæ—¥å¿—
  511              try:
  512                  target_ok = self._safe_path_operation(os.path.exists, self.target, timeout=1.5, default=False)
  513              except Exception:
  514                  target_ok = False
  515              if target_ok:
  516                  self.current_network_status = 'good'
  517              else:
  518                  try:
  519                      backup_ok = self._safe_path_operation(os.path.exists, self.backup, timeout=1.0, default=False)
  520                  except Exception:
  521                      backup_ok = False
  522                  self.current_network_status = 'unstable' if backup_ok else 'disconnected'
  523              self.last_network_check = now
  524              return self.current_network_status
  525  
  526          now = time.time()
  527          # æ ¹æ®é…ç½®çš„é—´éš”æ£€æŸ¥
  528          if now - self.last_network_check < self.network_check_interval:
  529              return self.current_network_status
  530          
  531          self.last_network_check = now
  532          
  533          # å¤šå±‚æ¬¡æ£€æµ‹ï¼ˆä½¿ç”¨å®‰å…¨æ“ä½œï¼Œå¸¦è¶…æ—¶ï¼‰
  534          # 1. å°è¯•è®¿é—®ç›®æ ‡æ–‡ä»¶å¤¹ï¼ˆä¸»è¦æ£€æµ‹ï¼Œ2ç§’è¶…æ—¶ï¼‰
  535          try:
  536              target_ok = self._safe_path_operation(os.path.exists, self.target, timeout=2.0, default=False)
  537          except Exception:
  538              target_ok = False
  539          
  540          if target_ok:
  541              # æˆåŠŸè®¿é—®ï¼Œç½‘ç»œè‰¯å¥½
  542              old_status = self.current_network_status
  543              self.current_network_status = 'good'
  544              self.network_retry_count = 0
  545              
  546              # çŠ¶æ€å˜åŒ–æ—¶å‘é€ä¿¡å·å’Œæ—¥å¿—
  547              if old_status == 'disconnected':

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 12 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  548                  self.log.emit("âœ… ç½‘ç»œå·²æ¢å¤æ­£å¸¸")
  549                  # å¦‚æœæ˜¯è‡ªåŠ¨æš‚åœï¼Œåˆ™è‡ªåŠ¨æ¢å¤
  550                  if self.network_auto_resume and self.network_pause_by_auto:
  551                      self.log.emit("ğŸ”„ ç½‘ç»œæ¢å¤ï¼Œè‡ªåŠ¨ç»§ç»­ä¸Šä¼ ...")
  552                      time.sleep(1)  # ç­‰å¾…1ç§’ç¡®ä¿ç½‘ç»œç¨³å®š
  553                      self.network_pause_by_auto = False
  554                      self.resume()
  555              elif old_status != 'good':
  556                  pass  # çŠ¶æ€æ”¹å–„
  557              
  558              # æ€»æ˜¯å‘é€çŠ¶æ€ä¿¡å·ï¼ˆç¡®ä¿UIæ›´æ–°ï¼‰
  559              self.network_status.emit('good')
  560              return 'good'
  561          
  562          # ç›®æ ‡ä¸å¯è¾¾ï¼Œç»§ç»­æ£€æµ‹
  563          self.network_retry_count += 1
  564          
  565          # 2. å°è¯•è®¿é—®å¤‡ä»½æ–‡ä»¶å¤¹ï¼ˆè¾…åŠ©æ£€æµ‹ï¼Œ2ç§’è¶…æ—¶ï¼‰
  566          try:
  567              backup_ok = self._safe_path_operation(os.path.exists, self.backup, timeout=2.0, default=False)
  568          except Exception:
  569              backup_ok = False
  570          
  571          if backup_ok:
  572              # ç›®æ ‡ä¸å¯è¾¾ï¼Œä½†å¤‡ä»½å¯è¾¾ - ç½‘ç»œä¸ç¨³å®š
  573              old_status = self.current_network_status
  574              self.current_network_status = 'unstable'
  575              
  576              if old_status != 'unstable':
  577                  self.log.emit(f"âš ï¸ ç½‘ç»œä¸ç¨³å®šï¼šç›®æ ‡æ–‡ä»¶å¤¹ä¸å¯è®¿é—®ï¼Œå¤‡ä»½æ–‡ä»¶å¤¹æ­£å¸¸")
  578              
  579              # æ€»æ˜¯å‘é€çŠ¶æ€ä¿¡å·
  580              self.network_status.emit('unstable')
  581              return 'unstable'
  582          
  583          # 3. å®Œå…¨æ–­å¼€
  584          old_status = self.current_network_status
  585          self.current_network_status = 'disconnected'
  586          
  587          if old_status != 'disconnected':
  588              self.log.emit(f"âŒ ç½‘ç»œè¿æ¥ä¸­æ–­ï¼ˆç›®æ ‡å’Œå¤‡ä»½æ–‡ä»¶å¤¹å‡ä¸å¯è®¿é—®ï¼‰")
  589              
  590              # è‡ªåŠ¨æš‚åœ
  591              if self.network_auto_pause and not self._paused:
  592                  self.log.emit("â¸ï¸ æ£€æµ‹åˆ°ç½‘ç»œä¸­æ–­ï¼Œè‡ªåŠ¨æš‚åœä¸Šä¼ ...")
  593                  self.network_pause_by_auto = True
  594                  self.pause()
  595          else:
  596              # å·²ç»æ˜¯æ–­å¼€çŠ¶æ€ï¼Œå®šæœŸæç¤º
  597              if self.network_retry_count % 3 == 0:

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 13 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  598                  self.log.emit(f"ğŸ”Œ ç½‘ç»œä»æœªæ¢å¤ (ç¬¬{self.network_retry_count}æ¬¡æ£€æµ‹)")
  599          
  600          # æ€»æ˜¯å‘é€çŠ¶æ€ä¿¡å·
  601          self.network_status.emit('disconnected')
  602          return 'disconnected'
  603  
  604      def _handle_upload_failure(self, file_path: str):
  605          """å¤„ç†ä¸Šä¼ å¤±è´¥ï¼šéé˜»å¡å¼é‡è¯•è°ƒåº¦ï¼ˆå¸¦æŒ‡æ•°å›é€€ï¼‰
  606          retry_queue ç»“æ„ï¼š{ path: { 'count': int, 'next': float } }
  607          """
  608          item = self.retry_queue.get(file_path)
  609          if item is None:
  610              item = {'count': 1, 'next': 0.0}
  611          else:
  612              item['count'] += 1
  613          
  614          retry_count = item['count']
  615          if retry_count > self.retry_count:
  616              # è¶…è¿‡é‡è¯•æ¬¡æ•°ï¼Œè®°å½•åˆ°å¤±è´¥æ—¥å¿—
  617              self._log_failed_file(file_path, f"é‡è¯•{retry_count-1}æ¬¡åä»ç„¶å¤±è´¥")
  618              if file_path in self.retry_queue:
  619                  del self.retry_queue[file_path]
  620              self.log.emit(f"âŒ æ–‡ä»¶ä¸Šä¼ å¤±è´¥ï¼Œå·²è®°å½•åˆ°å¤±è´¥æ—¥å¿—: {os.path.basename(file_path)}")
  621              return
  622          
  623          # è®¡ç®—ä¸‹ä¸€æ¬¡é‡è¯•æ—¶é—´ï¼ˆéé˜»å¡è°ƒåº¦ï¼‰
  624          wait_times = [10, 30, 60]
  625          wait_time = wait_times[min(retry_count - 1, len(wait_times) - 1)]
  626          item['next'] = time.time() + wait_time
  627          self.retry_queue[file_path] = item
  628          self.log.emit(f"âš  æ–‡ä»¶å°†åœ¨ç¨åé‡è¯• ({retry_count}/{self.retry_count})ï¼Œç­‰å¾…{wait_time}ç§’: {os.path.basename(file_path)}")
  629  
  630      def _process_retry_queue(self):
  631          """å¤„ç†é‡è¯•é˜Ÿåˆ—ï¼ˆéé˜»å¡ï¼ŒæŒ‰åˆ°æœŸæ—¶é—´è§¦å‘ï¼‰"""
  632          if not self.retry_queue:
  633              return
  634          now = time.time()
  635          retry_list = list(self.retry_queue.items())  # (path, item)
  636          for file_path, item in retry_list:
  637              if not self._running:
  638                  break
  639              if self._paused:
  640                  continue
  641              # æ–‡ä»¶ä¸å­˜åœ¨åˆ™ç§»é™¤
  642              if not os.path.exists(file_path):
  643                  del self.retry_queue[file_path]
  644                  continue
  645              retry_count = item.get('count', 1)
  646              next_at = item.get('next', 0.0)
  647              if now < next_at:

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 14 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  648                  # è¿˜æ²¡åˆ°æ—¶é—´
  649                  continue
  650              # åˆ°æ—¶é—´å°è¯•é‡è¯•
  651              self.log.emit(f"ğŸ“¤ å¼€å§‹é‡è¯•ä¸Šä¼  ({retry_count}/{self.retry_count}): {os.path.basename(file_path)}")
  652              rel = os.path.relpath(file_path, self.source)
  653              tgt = os.path.join(self.target, rel)
  654              bkp = os.path.join(self.backup, rel)
  655              try:
  656                  tgt_exists = self._safe_path_operation(os.path.exists, tgt, timeout=2.0, default=False)
  657                  if tgt_exists:
  658                      del self.retry_queue[file_path]
  659                      continue
  660                  # åˆ›å»ºç›®å½•
  661                  self._safe_path_operation(lambda: os.makedirs(os.path.dirname(tgt), exist_ok=True), timeout=3.0, default=False)
  662                  # å¤åˆ¶æ–‡ä»¶
  663                  copy_success = self._safe_path_operation(lambda: shutil.copy2(file_path, tgt) or True, timeout=10.0, default=False)
  664                  if not copy_success:
  665                      raise Exception("æ–‡ä»¶å¤åˆ¶è¶…æ—¶")
  666                  # æˆåŠŸ
  667                  self.archive_queue.put((file_path, bkp))
  668                  del self.retry_queue[file_path]
  669                  self.uploaded += 1
  670                  self.stats.emit(self.uploaded, self.failed, self.skipped, self.rate)
  671                  self.log.emit(f"âœ“ é‡è¯•æˆåŠŸ: {os.path.basename(file_path)}")
  672              except Exception as e:
  673                  # å¤±è´¥åˆ™å†æ¬¡è°ƒåº¦
  674                  item['count'] = retry_count + 1
  675                  if item['count'] > self.retry_count:
  676                      self._log_failed_file(file_path, f"é‡è¯•{retry_count}æ¬¡åä»ç„¶å¤±è´¥: {str(e)[:50]}")
  677                      del self.retry_queue[file_path]
  678                      self.failed += 1
  679                      self.stats.emit(self.uploaded, self.failed, self.skipped, self.rate)
  680                      self.log.emit(f"âŒ æ–‡ä»¶ä¸Šä¼ å¤±è´¥ï¼Œå·²è®°å½•åˆ°å¤±è´¥æ—¥å¿—: {os.path.basename(file_path)}")
  681                  else:
  682                      wait_times = [10, 30, 60]
  683                      wait_time = wait_times[min(item['count'] - 1, len(wait_times) - 1)]
  684                      item['next'] = time.time() + wait_time
  685                      self.retry_queue[file_path] = item
  686                      self.log.emit(f"âš  é‡è¯•å¤±è´¥ï¼Œå·²é‡æ–°æ’é˜Ÿ ({item['count']}/{self.retry_count})ï¼Œç­‰å¾…{wait_time}ç§’: {os.path.basename(file_path)}")
  687  
  688      def _log_failed_file(self, file_path: str, reason: str):
  689          """è®°å½•å¤±è´¥æ–‡ä»¶åˆ°æ—¥å¿—æ–‡ä»¶"""
  690          try:
  691              timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
  692              with open(self.failed_log_path, 'a', encoding='utf-8') as f:
  693                  f.write(f"[{timestamp}] {file_path} - {reason}\n")
  694          except Exception as e:
  695              self.log.emit(f"å†™å…¥å¤±è´¥æ—¥å¿—å‡ºé”™: {e}")
  696      
  697      def _copy_with_progress(self, src: str, dst: str, buffer_size: int = 1024 * 1024):

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 15 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  698          """v2.3.0 å¸¦è¿›åº¦å’Œé€Ÿç‡é™åˆ¶çš„æ–‡ä»¶å¤åˆ¶"""
  699          last_write_time = time.time()
  700          write_timeout = 5.0  # 5ç§’å†…æ²¡æœ‰å†™å…¥è§†ä¸ºè¶…æ—¶
  701          
  702          # v2.3.0 é€Ÿç‡é™åˆ¶ï¼šå¦‚æœå¯ç”¨ï¼Œå‡å°bufferä»¥æé«˜ç²¾ç¡®åº¦
  703          if self.limit_upload_rate and self.max_upload_rate_bytes > 0:
  704              buffer_size = min(buffer_size, 64 * 1024)  # 64KB chunks
  705          
  706          try:
  707              with open(src, 'rb') as fsrc:
  708                  with open(dst, 'wb') as fdst:
  709                      copied = 0
  710                      while True:
  711                          if not self._running or self._paused:
  712                              break
  713                          
  714                          # æ£€æŸ¥å†™å…¥è¶…æ—¶ï¼ˆå¯èƒ½æ˜¯ç½‘ç»œæ–­å¼€ï¼‰
  715                          if time.time() - last_write_time > write_timeout:
  716                              self.log.emit(f"â±ï¸ æ–‡ä»¶å†™å…¥è¶…æ—¶ï¼ˆ{write_timeout}ç§’ï¼‰ï¼Œå¯èƒ½ç½‘ç»œå·²æ–­å¼€")
  717                              raise Exception("æ–‡ä»¶å†™å…¥è¶…æ—¶")
  718                          
  719                          # v2.3.0 é€Ÿç‡é™åˆ¶ï¼šè®°å½•å¼€å§‹æ—¶é—´
  720                          chunk_start = time.time()
  721                          
  722                          buf = fsrc.read(buffer_size)
  723                          if not buf:
  724                              break
  725                          
  726                          # å†™å…¥æ“ä½œ
  727                          try:
  728                              fdst.write(buf)
  729                              last_write_time = time.time()  # é‡ç½®è¶…æ—¶è®¡æ—¶å™¨
  730                          except Exception as e:
  731                              self.log.emit(f"âš ï¸ æ–‡ä»¶å†™å…¥å¤±è´¥: {str(e)[:50]}")
  732                              raise
  733                          
  734                          copied += len(buf)
  735                          
  736                          # v2.3.0 é€Ÿç‡é™åˆ¶ï¼šè®¡ç®—åº”è¯¥èŠ±è´¹çš„æ—¶é—´
  737                          if self.limit_upload_rate and self.max_upload_rate_bytes > 0:
  738                              expected_time = len(buf) / self.max_upload_rate_bytes
  739                              elapsed_time = time.time() - chunk_start
  740                              if elapsed_time < expected_time:
  741                                  time.sleep(expected_time - elapsed_time)
  742                          
  743                          # æ›´æ–°è¿›åº¦ï¼ˆæ¯å¤åˆ¶1MBæ›´æ–°ä¸€æ¬¡ï¼‰
  744                          if self.current_file_size > 0:
  745                              progress = int(100 * copied / self.current_file_size)
  746                              self.file_progress.emit(self.current_file_name, progress)
  747                              # æ¯10%è¾“å‡ºæ—¥å¿—

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 16 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  748                              if progress % 10 == 0 and progress > 0:
  749                                  # v2.3.0 æ˜¾ç¤ºå®æ—¶é€Ÿç‡
  750                                  actual_speed_mbps = (copied / (1024 * 1024)) / (time.time() - chunk_start + 0.001)
  751                                  if self.limit_upload_rate:
  752                                      self.log.emit(f"ğŸ“Š ä¸Šä¼ è¿›åº¦: {progress}% ({copied/(1024*1024):.1f}MB/{self.current_file_size/(1024*1024):.1f}MB) [é™é€Ÿ: {self.max_upload_rate_bytes/(1024*1024):.1f}MB/s]")
  753                                  else:
  754                                      self.log.emit(f"ğŸ“Š ä¸Šä¼ è¿›åº¦: {progress}% ({copied/(1024*1024):.1f}MB/{self.current_file_size/(1024*1024):.1f}MB)")
  755              
  756              # å¤åˆ¶æ–‡ä»¶å…ƒæ•°æ®
  757              shutil.copystat(src, dst)
  758          except Exception as e:
  759              # å¦‚æœå¤åˆ¶å¤±è´¥ï¼Œåˆ é™¤ä¸å®Œæ•´çš„æ–‡ä»¶
  760              if os.path.exists(dst):
  761                  try:
  762                      os.remove(dst)
  763                  except:
  764                      pass
  765              raise e
  766      
  767      # v2.0 æ–°å¢ï¼šå¤šåè®®ä¸Šä¼ æ”¯æŒ
  768      def _upload_file_by_protocol(self, src: str, dst: str) -> bool:
  769          """
  770          æ ¹æ®é…ç½®çš„åè®®ä¸Šä¼ æ–‡ä»¶
  771          
  772          Args:
  773              src: æºæ–‡ä»¶è·¯å¾„
  774              dst: ç›®æ ‡æ–‡ä»¶è·¯å¾„ï¼ˆSMBè·¯å¾„æˆ–æœ¬åœ°è·¯å¾„ï¼‰
  775          
  776          Returns:
  777              bool: ä¸Šä¼ æ˜¯å¦æˆåŠŸ
  778          """
  779          if self.upload_protocol == 'smb':
  780              # SMBåè®®ï¼šç›´æ¥ä½¿ç”¨æ–‡ä»¶ç³»ç»Ÿå¤åˆ¶
  781              return self._upload_via_smb(src, dst)
  782          elif self.upload_protocol == 'ftp_client':
  783              # FTPå®¢æˆ·ç«¯æ¨¡å¼ï¼šä¸Šä¼ åˆ°FTPæœåŠ¡å™¨
  784              return self._upload_via_ftp(src, dst)
  785          elif self.upload_protocol == 'both':
  786              # æ··åˆæ¨¡å¼ï¼šåŒæ—¶ä½¿ç”¨SMBå’ŒFTP
  787              smb_ok = self._upload_via_smb(src, dst)
  788              ftp_ok = self._upload_via_ftp(src, dst)
  789              return smb_ok or ftp_ok  # ä»»ä¸€æˆåŠŸå³è§†ä¸ºæˆåŠŸ
  790          else:
  791              self.log.emit(f"âŒ æœªçŸ¥çš„ä¸Šä¼ åè®®: {self.upload_protocol}")
  792              return False
  793      
  794      def _upload_via_smb(self, src: str, dst: str) -> bool:
  795          """é€šè¿‡SMBåè®®ä¸Šä¼ æ–‡ä»¶ï¼ˆä½¿ç”¨shutil.copy2ï¼‰"""
  796          try:
  797              # å¯¹äºå¤§æ–‡ä»¶ï¼Œæ˜¾ç¤ºä¸Šä¼ è¿›åº¦

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 17 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  798              if self.current_file_size > 10 * 1024 * 1024:  # å¤§äº10MB
  799                  self._copy_with_progress(src, dst)
  800              else:
  801                  # å°æ–‡ä»¶ä¹Ÿä½¿ç”¨è¶…æ—¶ä¿æŠ¤
  802                  def copy_file():
  803                      shutil.copy2(src, dst)
  804                      return True
  805                  
  806                  copy_success = self._safe_path_operation(copy_file, timeout=10.0, default=False)
  807                  if not copy_success:
  808                      raise Exception("æ–‡ä»¶å¤åˆ¶è¶…æ—¶ï¼Œç½‘ç»œå¯èƒ½å·²æ–­å¼€")
  809              
  810              return True
  811          except Exception as e:
  812              self.log.emit(f"âŒ SMBä¸Šä¼ å¤±è´¥: {e}")
  813              return False
  814      
  815      def _upload_via_ftp(self, src: str, dst: str) -> bool:
  816          """é€šè¿‡FTPåè®®ä¸Šä¼ æ–‡ä»¶"""
  817          try:
  818              # åˆå§‹åŒ–FTPå®¢æˆ·ç«¯ï¼ˆå¦‚æœè¿˜æœªåˆå§‹åŒ–ï¼‰
  819              if not self.ftp_client and self.ftp_client_config:
  820                  self.ftp_client = FTPClientUploader(self.ftp_client_config)
  821                  if not self.ftp_client.connect():
  822                      # v2.0 å¢å¼ºï¼šè¯¦ç»†é”™è¯¯æ—¥å¿—
  823                      host = self.ftp_client_config.get('host', 'unknown')
  824                      port = self.ftp_client_config.get('port', 21)
  825                      self.log.emit(f"âŒ [FTP-CONN] æ— æ³•è¿æ¥åˆ° {host}:{port}")
  826                      self.ftp_client = None
  827                      return False
  828              
  829              if not self.ftp_client:
  830                  self.log.emit("âŒ [FTP-INIT] FTPå®¢æˆ·ç«¯æœªåˆå§‹åŒ–")
  831                  return False
  832              
  833              # è®¡ç®—è¿œç¨‹è·¯å¾„ï¼ˆä½¿ç”¨ç›¸å¯¹è·¯å¾„ï¼‰
  834              rel_path = os.path.relpath(dst, self.target)
  835              remote_path = self.ftp_client_config.get('remote_path', '/upload')
  836              remote_file = f"{remote_path}/{rel_path}".replace('\\', '/')
  837              
  838              # ä¸Šä¼ æ–‡ä»¶
  839              success = self.ftp_client.upload_file(Path(src), remote_file)
  840              if success:
  841                  self.log.emit(f"âœ“ FTPä¸Šä¼ æˆåŠŸ: {os.path.basename(remote_file)}")
  842                  return True
  843              else:
  844                  # v2.0 å¢å¼ºï¼šè¯¦ç»†é”™è¯¯æ—¥å¿—
  845                  self.log.emit(f"âŒ [FTP-UPLOAD] ä¸Šä¼ å¤±è´¥: {os.path.basename(remote_file)}")
  846                  return False
  847                  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 18 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  848          except Exception as e:
  849              # v2.0 å¢å¼ºï¼šè¯¦ç»†é”™è¯¯æ—¥å¿—ï¼ŒåŒ…å«å¼‚å¸¸ç±»å‹
  850              error_type = type(e).__name__
  851              self.log.emit(f"âŒ [FTP-ERROR] {error_type}: {e}")
  852              return False
  853      
  854      def _calculate_file_hash(self, file_path: str, buffer_size: int = 8192) -> str:
  855          """è®¡ç®—æ–‡ä»¶å“ˆå¸Œå€¼ï¼ˆMD5æˆ–SHA256ï¼‰"""
  856          try:
  857              if self.hash_algorithm == 'sha256':
  858                  hasher = hashlib.sha256()
  859              else:
  860                  hasher = hashlib.md5()
  861              
  862              file_size = os.path.getsize(file_path)
  863              
  864              with open(file_path, 'rb') as f:
  865                  processed = 0
  866                  while True:
  867                      if not self._running or self._paused:
  868                          return ""
  869                      
  870                      data = f.read(buffer_size)
  871                      if not data:
  872                          break
  873                      hasher.update(data)
  874                      processed += len(data)
  875                      
  876                      # å¤§æ–‡ä»¶æ˜¾ç¤ºå“ˆå¸Œè®¡ç®—è¿›åº¦
  877                      if file_size > 50 * 1024 * 1024:  # å¤§äº50MB
  878                          progress = int(100 * processed / file_size)
  879                          if progress % 10 == 0:  # æ¯10%æ˜¾ç¤ºä¸€æ¬¡
  880                              self.log.emit(f"ğŸ” è®¡ç®—å“ˆå¸Œå€¼... {progress}%")
  881              
  882              return hasher.hexdigest()
  883          except Exception as e:
  884              self.log.emit(f"âš  å“ˆå¸Œè®¡ç®—å¤±è´¥: {e}")
  885              return ""
  886      
  887      def _find_duplicate_by_hash(self, file_hash: str, target_dir: str) -> str:
  888          """åœ¨ç›®æ ‡æ–‡ä»¶å¤¹ä¸­æŸ¥æ‰¾ç›¸åŒå“ˆå¸Œçš„æ–‡ä»¶"""
  889          if not file_hash:
  890              return ""
  891          
  892          try:
  893              for root, _, files in os.walk(target_dir):
  894                  for name in files:
  895                      if not self._running or self._paused:
  896                          return ""
  897                      

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 19 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  898                      target_file = os.path.join(root, name)
  899                      try:
  900                          target_hash = self._calculate_file_hash(target_file)
  901                          if target_hash == file_hash:
  902                              return target_file
  903                      except Exception:
  904                          continue
  905              return ""
  906          except Exception:
  907              return ""
  908      
  909      def _get_unique_filename(self, base_path: str) -> str:
  910          """ç”Ÿæˆå”¯ä¸€çš„æ–‡ä»¶åï¼ˆæ·»åŠ åºå·ï¼‰"""
  911          if not os.path.exists(base_path):
  912              return base_path
  913          
  914          directory = os.path.dirname(base_path)
  915          filename = os.path.basename(base_path)
  916          name, ext = os.path.splitext(filename)
  917          
  918          counter = 1
  919          while True:
  920              new_name = f"{name} ({counter}){ext}"
  921              new_path = os.path.join(directory, new_name)
  922              if not os.path.exists(new_path):
  923                  return new_path
  924              counter += 1
  925              if counter > 9999:  # é˜²æ­¢æ— é™å¾ªç¯
  926                  return base_path
  927  
  928      def _archive_worker(self):
  929          """ç‹¬ç«‹å½’æ¡£çº¿ç¨‹ï¼ˆé¿å…é˜»å¡ä¸Šä¼ ï¼‰
  930          v2.1.1 ä¿®æ”¹ï¼šæ ¹æ® enable_backup é…ç½®å†³å®šæ˜¯å½’æ¡£è¿˜æ˜¯åˆ é™¤
  931          """
  932          while self._running:
  933              try:
  934                  # 1ç§’è¶…æ—¶ï¼Œé¿å…æ­»ç­‰
  935                  item = self.archive_queue.get(timeout=1)
  936                  src_path, bkp_path = item
  937                  
  938                  if not os.path.exists(src_path):
  939                      continue
  940                  
  941                  # v2.1.1ï¼šæ ¹æ®å¤‡ä»½å¯ç”¨çŠ¶æ€å†³å®šæ“ä½œ
  942                  if self.enable_backup and self.backup and os.path.exists(os.path.dirname(self.backup)):
  943                      # å¯ç”¨å¤‡ä»½ï¼šç§»åŠ¨åˆ°å¤‡ä»½æ–‡ä»¶å¤¹
  944                      os.makedirs(os.path.dirname(bkp_path), exist_ok=True)
  945                      shutil.move(src_path, bkp_path)
  946                      self.log.emit(f"ğŸ“¦ å·²å½’æ¡£: {os.path.basename(bkp_path)}")
  947                  else:

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 20 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  948                      # æœªå¯ç”¨å¤‡ä»½ï¼šç›´æ¥åˆ é™¤æºæ–‡ä»¶
  949                      os.remove(src_path)
  950                      self.log.emit(f"ğŸ—‘ï¸ å·²åˆ é™¤: {os.path.basename(src_path)}")
  951              except queue.Empty:
  952                  continue
  953              except Exception as e:
  954                  self.log.emit(f"å½’æ¡£å¤±è´¥: {e}")
  955  
  956      def _disk_ok(self, path: str) -> Tuple[float, float, float]:
  957          """æ£€æŸ¥ç£ç›˜ç©ºé—´ï¼ˆå¸¦è¶…æ—¶ä¿æŠ¤ï¼‰"""
  958          def check():
  959              try:
  960                  parent = os.path.dirname(path) or path
  961                  usage = shutil.disk_usage(parent)
  962                  total_gb = usage.total / (1024 ** 3)
  963                  free_gb = usage.free / (1024 ** 3)
  964                  free_percent = (usage.free / usage.total) * 100 if usage.total > 0 else 0
  965                  return free_percent, total_gb, free_gb
  966              except Exception:
  967                  return 0.0, 0.0, 0.0
  968          
  969          # ä½¿ç”¨å®‰å…¨æ“ä½œï¼Œ2ç§’è¶…æ—¶
  970          result = self._safe_path_operation(check, timeout=2.0, default=(0.0, 0.0, 0.0))
  971          return result if result is not None else (0.0, 0.0, 0.0)
  972  
  973      def _get_image_files(self) -> List[str]:
  974          """æ‰«æå›¾ç‰‡æ–‡ä»¶ï¼ˆå¸¦è¶…æ—¶ä¿æŠ¤ï¼‰"""
  975          def scan():
  976              if not os.path.exists(self.source):
  977                  return []
  978              files = []
  979              for root, _, names in os.walk(self.source):
  980                  if not self._running:  # æ”¯æŒä¸­æ–­
  981                      break
  982                  for n in names:
  983                      ext = os.path.splitext(n)[1].lower()
  984                      if ext in self.filters:
  985                          files.append(os.path.join(root, n))
  986              return files
  987          
  988          # ä½¿ç”¨å®‰å…¨æ“ä½œï¼Œ5ç§’è¶…æ—¶ï¼ˆæ‰«æå¯èƒ½éœ€è¦æ›´é•¿æ—¶é—´ï¼‰
  989          result = self._safe_path_operation(scan, timeout=5.0, default=[])
  990          return result if result is not None else []
  991  
  992      def _run(self):
  993          self.log.emit("ğŸš€ å¼€å§‹å›¾ç‰‡ä¸Šä¼ æœåŠ¡ï¼ˆä¸Šä¼ ä¸å½’æ¡£å·²åˆ†ç¦»ï¼‰")
  994          self.start_time = time.time()
  995          
  996          # å¯åŠ¨ç‹¬ç«‹å½’æ¡£çº¿ç¨‹
  997          self._archive_thread = threading.Thread(target=self._archive_worker, daemon=True)

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 21 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
  998          self._archive_thread.start()
  999          self.log.emit("ğŸ“¦ å½’æ¡£çº¿ç¨‹å·²å¯åŠ¨")
 1000          
 1001          # é‡ç½®çŠ¶æ€
 1002          self.uploaded = 0
 1003          self.failed = 0
 1004          self.skipped = 0
 1005          self.retry_queue.clear()
 1006          
 1007          try:
 1008              while self._running:
 1009                  # æš‚åœ
 1010                  pause_log_counter = 0
 1011                  while self._paused and self._running:
 1012                      time.sleep(0.2)
 1013                      # æ¯10ç§’ï¼ˆ50æ¬¡å¾ªç¯ï¼‰è¾“å‡ºä¸€æ¬¡æš‚åœçŠ¶æ€æ—¥å¿—
 1014                      pause_log_counter += 1
 1015                      if pause_log_counter >= 50:
 1016                          pause_log_counter = 0
 1017                          self.log.emit("â¸ï¸ ä¸Šä¼ å·²æš‚åœï¼Œç­‰å¾…æ¢å¤...")
 1018                  if not self._running:
 1019                      break
 1020  
 1021                  # ç½‘ç»œè¿æ¥æ£€æŸ¥ï¼ˆæ ¹æ®é…ç½®é—´éš”ï¼‰
 1022                  try:
 1023                      network_status = self._check_network_connection()
 1024                  except Exception as e:
 1025                      self.log.emit(f"âš ï¸ ç½‘ç»œæ£€æµ‹å¼‚å¸¸: {str(e)[:50]}")
 1026                      network_status = 'disconnected'
 1027                  
 1028                  # å¦‚æœç½‘ç»œæ–­å¼€ä¸”å·²æš‚åœï¼Œç­‰å¾…ç½‘ç»œæ¢å¤
 1029                  if network_status == 'disconnected' and self._paused:
 1030                      self.log.emit("ğŸ”Œ ç­‰å¾…ç½‘ç»œæ¢å¤ä¸­...")
 1031                      time.sleep(1)
 1032                      continue
 1033  
 1034                  # ç©ºé—´æ£€æŸ¥ï¼ˆå¸¦è­¦å‘Šï¼‰
 1035                  tf_ok, _, _ = self._disk_ok(self.target)
 1036                  bf_ok, _, _ = self._disk_ok(self.backup)
 1037                  if tf_ok < self.disk_threshold_percent or bf_ok < self.disk_threshold_percent:
 1038                      now = time.time()
 1039                      if now - self._last_space_warn > 10:
 1040                          self._last_space_warn = now
 1041                          self.log.emit(f"âš  ç£ç›˜ç©ºé—´ä¸è¶³ï¼ç›®æ ‡:{tf_ok:.0f}%ï¼Œå¤‡ä»½:{bf_ok:.0f}%ï¼ˆé˜ˆå€¼:{self.disk_threshold_percent}%ï¼‰")
 1042                          # v2.2.0 å‘é€ç£ç›˜ç©ºé—´è­¦å‘Šä¿¡å·
 1043                          self.disk_warning.emit(tf_ok, bf_ok, self.disk_threshold_percent)
 1044                      time.sleep(2)
 1045                      continue
 1046  
 1047                  # å¤„ç†é‡è¯•é˜Ÿåˆ—

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 22 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
 1048                  self._process_retry_queue()
 1049  
 1050                  # æ‰«æä¸å¤„ç†
 1051                  images = self._get_image_files()
 1052                  self.total_files = len(images)
 1053                  self.current = 0
 1054                  self.progress.emit(self.current, self.total_files, "")
 1055  
 1056                  for path in images:
 1057                      if not self._running:
 1058                          break
 1059                      while self._paused and self._running:
 1060                          time.sleep(0.2)
 1061                      if not self._running:
 1062                          break
 1063                      
 1064                      # åœ¨æ¯ä¸ªæ–‡ä»¶ä¸Šä¼ å‰å¿«é€Ÿæ£€æŸ¥ç½‘ç»œçŠ¶æ€
 1065                      network_status = self._check_network_connection()
 1066                      if network_status == 'disconnected':
 1067                          self.log.emit("âš ï¸ ç½‘ç»œå·²æ–­å¼€ï¼Œåœæ­¢ä¸Šä¼ æ–°æ–‡ä»¶")
 1068                          time.sleep(1)
 1069                          continue
 1070  
 1071                      rel = os.path.relpath(path, self.source)
 1072                      tgt = os.path.join(self.target, rel)
 1073                      bkp = os.path.join(self.backup, rel)
 1074                      
 1075                      # å®‰å…¨åˆ›å»ºç›®å½•ï¼ˆå¸¦è¶…æ—¶ï¼‰
 1076                      try:
 1077                          self._safe_path_operation(
 1078                              lambda: os.makedirs(os.path.dirname(tgt), exist_ok=True),
 1079                              timeout=3.0
 1080                          )
 1081                      except Exception as e:
 1082                          self.log.emit(f"âŒ æ— æ³•åˆ›å»ºç›®æ ‡ç›®å½•: {e}")
 1083                          self.failed += 1
 1084                          self.stats.emit(self.uploaded, self.failed, self.skipped, self.rate)
 1085                          continue
 1086  
 1087                      fname = os.path.basename(path)
 1088                      self.current_file_name = fname
 1089                      
 1090                      self.log.emit(f"ğŸ“¤ å¼€å§‹ä¸Šä¼ : {fname}")
 1091                      self.progress.emit(self.current, self.total_files, fname)
 1092                      start_t = time.time()
 1093                      try:
 1094                          # åŸºæœ¬æ£€æŸ¥ï¼šç›®æ ‡æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼ˆä¸å¯ç”¨å»é‡æ—¶çš„é»˜è®¤è¡Œä¸ºï¼Œå¸¦è¶…æ—¶ï¼‰
 1095                          tgt_exists = self._safe_path_operation(os.path.exists, tgt, timeout=2.0, default=False)
 1096                          if tgt_exists and not self.enable_deduplication:
 1097                              self.log.emit(f"â­ æ–‡ä»¶å·²å­˜åœ¨ï¼Œè·³è¿‡: {fname}")

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 23 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
 1098                              self.skipped += 1
 1099                              self.stats.emit(self.uploaded, self.failed, self.skipped, self.rate)
 1100                              self.file_progress.emit(fname, 100)
 1101                          else:
 1102                              # è·å–æ–‡ä»¶å¤§å°
 1103                              try:
 1104                                  self.current_file_size = os.path.getsize(path)
 1105                              except:
 1106                                  self.current_file_size = 0
 1107                              
 1108                              # å‘é€å¼€å§‹ä¸Šä¼ ä¿¡å·ï¼ˆ0%ï¼‰
 1109                              self.file_progress.emit(fname, 0)
 1110                              
 1111                              # ===== æ™ºèƒ½å»é‡é€»è¾‘ =====
 1112                              should_upload = True
 1113                              final_target = tgt
 1114                              
 1115                              if self.enable_deduplication:
 1116                                  self.log.emit(f"ğŸ” æ£€æŸ¥é‡å¤æ–‡ä»¶ï¼ˆ{self.hash_algorithm.upper()}ï¼‰...")
 1117                                  file_hash = self._calculate_file_hash(path)
 1118                                  
 1119                                  if file_hash:
 1120                                      duplicate = self._find_duplicate_by_hash(file_hash, self.target)
 1121                                      
 1122                                      if duplicate:
 1123                                          self.log.emit(f"âš  å‘ç°é‡å¤æ–‡ä»¶: {os.path.basename(duplicate)}")
 1124                                          
 1125                                          if self.duplicate_strategy == 'skip':
 1126                                              self.log.emit(f"â­ è·³è¿‡é‡å¤æ–‡ä»¶: {fname}")
 1127                                              self.skipped += 1
 1128                                              self.stats.emit(self.uploaded, self.failed, self.skipped, self.rate)
 1129                                              should_upload = False
 1130                                              # ç›´æ¥å½’æ¡£æºæ–‡ä»¶
 1131                                              self.archive_queue.put((path, bkp))
 1132                                          elif self.duplicate_strategy == 'rename':
 1133                                              final_target = self._get_unique_filename(tgt)
 1134                                              self.log.emit(f"ğŸ“ é‡å‘½å: {os.path.basename(final_target)}")
 1135                                          elif self.duplicate_strategy == 'overwrite':
 1136                                              self.log.emit(f"ğŸ”„ è¦†ç›–ç°æœ‰æ–‡ä»¶")
 1137                                              try:
 1138                                                  os.remove(duplicate)
 1139                                              except Exception:
 1140                                                  pass
 1141                                          # 'ask' ç­–ç•¥æš‚æ—¶æŒ‰ skip å¤„ç†ï¼ˆéœ€è¦UIå¼¹çª—ï¼Œåç»­å®ç°ï¼‰
 1142                                          elif self.duplicate_strategy == 'ask':
 1143                                              # å¦‚æœå·²æœ‰ç”¨æˆ·é€‰æ‹©â€œåº”ç”¨äºåç»­â€ï¼Œç›´æ¥ä½¿ç”¨
 1144                                              choice = self._duplicate_ask_choice
 1145                                              if choice is None:
 1146                                                  # é€šè¿‡ä¿¡å·è¯·æ±‚ä¸»çº¿ç¨‹å¼¹çª—
 1147                                                  evt = threading.Event()

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 24 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
 1148                                                  payload = {
 1149                                                      'file': path,
 1150                                                      'duplicate': duplicate,
 1151                                                      'event': evt,
 1152                                                      'result': {},
 1153                                                  }
 1154                                                  try:
 1155                                                      self.ask_user_duplicate.emit(payload)
 1156                                                      # æœ€é•¿ç­‰å¾…120ç§’ç”¨æˆ·é€‰æ‹©
 1157                                                      evt.wait(timeout=120)
 1158                                                  except Exception:
 1159                                                      pass
 1160                                                  choice = payload.get('result', {}).get('choice') or 'skip'
 1161                                                  apply_all = bool(payload.get('result', {}).get('apply_all'))
 1162                                                  if apply_all:
 1163                                                      self._duplicate_ask_choice = choice
 1164                                              # æ ¹æ®é€‰æ‹©å¤„ç†
 1165                                              if choice == 'skip':
 1166                                                  self.log.emit(f"â­ è·³è¿‡é‡å¤æ–‡ä»¶: {fname}")
 1167                                                  self.skipped += 1
 1168                                                  self.stats.emit(self.uploaded, self.failed, self.skipped, self.rate)
 1169                                                  should_upload = False
 1170                                                  self.archive_queue.put((path, bkp))
 1171                                              elif choice == 'rename':
 1172                                                  final_target = self._get_unique_filename(tgt)
 1173                                                  self.log.emit(f"ğŸ“ é‡å‘½å: {os.path.basename(final_target)}")
 1174                                              elif choice == 'overwrite':
 1175                                                  self.log.emit(f"ğŸ”„ è¦†ç›–ç°æœ‰æ–‡ä»¶")
 1176                                                  try:
 1177                                                      os.remove(duplicate)
 1178                                                  except Exception:
 1179                                                      pass
 1180                              
 1181                              # ===== æ‰§è¡Œä¸Šä¼  =====
 1182                              if should_upload:
 1183                                  # åˆ›å»ºç›®æ ‡ç›®å½•ï¼ˆå¸¦è¶…æ—¶ä¿æŠ¤ï¼‰
 1184                                  def create_dir():
 1185                                      os.makedirs(os.path.dirname(final_target), exist_ok=True)
 1186                                  
 1187                                  dir_created = self._safe_path_operation(create_dir, timeout=3.0, default=False)
 1188                                  if dir_created is False:
 1189                                      raise Exception("åˆ›å»ºç›®æ ‡ç›®å½•è¶…æ—¶ï¼Œç½‘ç»œå¯èƒ½å·²æ–­å¼€")
 1190                                  
 1191                                  # v2.0 æ–°å¢ï¼šä½¿ç”¨åè®®è·¯ç”±ä¸Šä¼ æ–‡ä»¶
 1192                                  upload_success = self._upload_file_by_protocol(path, final_target)
 1193                                  
 1194                                  if not upload_success:
 1195                                      raise Exception("æ–‡ä»¶ä¸Šä¼ å¤±è´¥")
 1196                                  
 1197                                  self.uploaded += 1

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 25 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
 1198                                  # é€Ÿç‡è®¡ç®—
 1199                                  try: 
 1200                                      size_mb = os.path.getsize(final_target) / (1024*1024)
 1201                                      dur = max(time.time()-start_t, 1e-6)
 1202                                      rate = size_mb / dur
 1203                                      self.rate = f"{rate:.2f} MB/s"
 1204                                  except Exception:
 1205                                      pass
 1206                                  self.stats.emit(self.uploaded, self.failed, self.skipped, self.rate)
 1207                                  self.file_progress.emit(fname, 100)
 1208                                  self.log.emit(f"âœ“ ä¸Šä¼ æˆåŠŸ: {os.path.basename(final_target)}")
 1209                                  # æ”¾å…¥å½’æ¡£é˜Ÿåˆ—
 1210                                  self.archive_queue.put((path, bkp))
 1211                              else:
 1212                                  self.file_progress.emit(fname, 100)
 1213                      except Exception as e:
 1214                          self.failed += 1
 1215                          self.stats.emit(self.uploaded, self.failed, self.skipped, self.rate)
 1216                          self.log.emit(f"âœ— ä¸Šä¼ å¤±è´¥ {fname}: {e}")
 1217                          # v2.2.0 å‘é€é”™è¯¯é€šçŸ¥ä¿¡å·
 1218                          self.upload_error.emit(fname, str(e))
 1219                          # æ·»åŠ åˆ°é‡è¯•é˜Ÿåˆ—
 1220                          self._handle_upload_failure(path)
 1221  
 1222                      self.current += 1
 1223                      self.progress.emit(self.current, self.total_files, fname)
 1224  
 1225                  # é—´éš”
 1226                  if self.mode == 'periodic':
 1227                      for _ in range(max(1, self.interval*5)):
 1228                          if not self._running or self._paused:
 1229                              break
 1230                          time.sleep(0.2)
 1231                  else:
 1232                      time.sleep(1)
 1233          finally:
 1234              self.log.emit("ğŸ›‘ ä¸Šä¼ æœåŠ¡å·²åœæ­¢")
 1235              self.finished.emit()
 1236  
 1237  
 1238  # v2.3.1 æ¨¡å—åŒ–ç»„ä»¶åˆ«åï¼ˆä¼˜å…ˆä½¿ç”¨æ¨¡å—åŒ–ç‰ˆæœ¬ï¼Œå›é€€åˆ°å†…ç½®ç‰ˆæœ¬ï¼‰
 1239  # è¿™æ ·å¯ä»¥é€æ­¥è¿ç§»åˆ°æ¨¡å—åŒ–æ¶æ„ï¼ŒåŒæ—¶ä¿æŒå‘åå…¼å®¹
 1240  if MODULAR_COMPONENTS_AVAILABLE:
 1241      # ä½¿ç”¨æ¨¡å—åŒ–ç»„ä»¶ï¼ˆæ¨èï¼‰
 1242      Toast = ModularToast  # type: ignore[misc, assignment]
 1243      ChipWidget = ModularChipWidget  # type: ignore[misc, assignment]
 1244      CollapsibleBox = ModularCollapsibleBox  # type: ignore[misc, assignment]
 1245      DiskCleanupDialog = ModularDiskCleanupDialog  # type: ignore[misc, assignment]
 1246      UploadWorker = ModularUploadWorker  # type: ignore[misc, assignment]
 1247  # else: ä½¿ç”¨å†…ç½®ç»„ä»¶ï¼ˆå·²åœ¨ä¸‹æ–¹å®šä¹‰ï¼‰

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 26 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
 1248  
 1249  
 1250  
 1251  def main():
 1252      app = QtWidgets.QApplication(sys.argv)
 1253      
 1254      # v2.3.1 å•ä¾‹æ¨¡å¼å¢å¼ºï¼šä½¿ç”¨ LocalSocket å°è¯•å”¤é†’å·²è¿è¡Œçš„å®ä¾‹
 1255      server_name = "ImageUploadTool_SingleInstance_Server"
 1256      socket = QLocalSocket()
 1257      socket.connectToServer(server_name)
 1258      
 1259      # å°è¯•è¿æ¥åˆ°å·²è¿è¡Œçš„å®ä¾‹
 1260      if socket.waitForConnected(500):  # ç­‰å¾…500ms
 1261          # è¿æ¥æˆåŠŸï¼Œè¯´æ˜ç¨‹åºå·²åœ¨è¿è¡Œ
 1262          # å‘é€å”¤é†’æ¶ˆæ¯
 1263          socket.write(b"WAKEUP")
 1264          socket.flush()
 1265          socket.waitForBytesWritten(1000)
 1266          socket.disconnectFromServer()
 1267          
 1268          # æ˜¾ç¤ºæç¤ºï¼ˆå¯é€‰ï¼Œä¹Ÿå¯ä»¥é™é»˜é€€å‡ºï¼‰
 1269          # è¿™é‡Œé€‰æ‹©é™é»˜é€€å‡ºï¼Œå› ä¸ºå·²ç»å”¤é†’äº†æ—§å®ä¾‹
 1270          return
 1271      
 1272      # è¿æ¥å¤±è´¥ï¼Œè¯´æ˜æ²¡æœ‰å…¶ä»–å®ä¾‹åœ¨è¿è¡Œ
 1273      # ä½¿ç”¨å…±äº«å†…å­˜ä½œä¸ºè¾…åŠ©é”ï¼ˆé˜²æ­¢æç«¯æƒ…å†µä¸‹çš„ç«æ€æ¡ä»¶ï¼‰
 1274      shared_mem = QtCore.QSharedMemory("ImageUploadTool_SingleInstance")
 1275      if not shared_mem.create(1):
 1276          # æå°‘æƒ…å†µï¼šLocalServer æœªå“åº”ä½†å…±äº«å†…å­˜å­˜åœ¨
 1277          # è¿™å¯èƒ½æ˜¯ä¸Šæ¬¡ç¨‹åºå¼‚å¸¸é€€å‡ºå¯¼è‡´çš„ï¼Œæç¤ºç”¨æˆ·
 1278          msg = QtWidgets.QMessageBox()
 1279          msg.setIcon(QtWidgets.QMessageBox.Icon.Warning)
 1280          msg.setWindowTitle("ç¨‹åºå¯åŠ¨å¼‚å¸¸")
 1281          msg.setText("æ£€æµ‹åˆ°ç¨‹åºå¯èƒ½æœªæ­£å¸¸é€€å‡º")
 1282          msg.setInformativeText("å»ºè®®ï¼š\n1. æ£€æŸ¥ä»»åŠ¡ç®¡ç†å™¨æ˜¯å¦æœ‰æ®‹ç•™è¿›ç¨‹\n2. é‡å¯è®¡ç®—æœºåé‡è¯•")
 1283          msg.setStandardButtons(QtWidgets.QMessageBox.StandardButton.Ok)
 1284          msg.exec() if hasattr(msg, 'exec') else msg.exec_()
 1285          return
 1286      
 1287      # åˆ›å»ºä¸»çª—å£
 1288      w = MainWindow()
 1289      w.show()
 1290      
 1291      # å…¼å®¹ PyQt5 å’Œ PySide6
 1292      try:
 1293          sys.exit(app.exec())  # PySide6 / PyQt6
 1294      except AttributeError:
 1295          sys.exit(app.exec_())  # PyQt5
 1296  
 1297  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 27 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
 1298  if __name__ == '__main__':
 1299      main()
       
       # ============================================================
       # æ–‡ä»¶: qt_types.py
       # ============================================================
 1300  """
 1301  Qt ç±»å‹æç¤ºå’Œæšä¸¾è®¿é—®è¾…åŠ©
 1302  ä¸º PySide6/PyQt5 æä¾›ç±»å‹å®‰å…¨çš„æšä¸¾è®¿é—®ï¼Œé¿å…ä½¿ç”¨ type: ignore
 1303  """
 1304  from typing import Any, TYPE_CHECKING
 1305  
 1306  if TYPE_CHECKING:
 1307      # ä»…ç”¨äºç±»å‹æ£€æŸ¥æ—¶çš„å¯¼å…¥
 1308      try:
 1309          from PySide6 import QtWidgets, QtCore
 1310      except ImportError:
 1311          from PyQt5 import QtWidgets, QtCore  # type: ignore
 1312  
 1313  
 1314  # ============================================
 1315  # ç±»å‹å®‰å…¨çš„æšä¸¾è®¿é—®å™¨
 1316  # ============================================
 1317  
 1318  class QtEnumAccessor:
 1319      """Qt æšä¸¾çš„ç±»å‹å®‰å…¨è®¿é—®å™¨
 1320      
 1321      è§£å†³ PySide6 å¼ºç±»å‹æšä¸¾åœ¨ Pylance ä¸­çš„ç±»å‹æ£€æŸ¥é—®é¢˜
 1322      é€šè¿‡å»¶è¿Ÿè·å–æšä¸¾å€¼ï¼Œé¿å…ç›´æ¥ä½¿ç”¨ type: ignore
 1323      """
 1324      
 1325      _qt_widgets: Any = None
 1326      _qt_core: Any = None
 1327      
 1328      @classmethod
 1329      def _ensure_qt_imported(cls):
 1330          """ç¡®ä¿ Qt æ¨¡å—å·²å¯¼å…¥"""
 1331          if cls._qt_widgets is None:
 1332              try:
 1333                  from PySide6 import QtWidgets, QtCore
 1334                  cls._qt_widgets = QtWidgets
 1335                  cls._qt_core = QtCore
 1336              except ImportError:
 1337                  from PyQt5 import QtWidgets, QtCore  # type: ignore
 1338                  cls._qt_widgets = QtWidgets
 1339                  cls._qt_core = QtCore
 1340      
 1341      @classmethod
 1342      def get_message_box_icon(cls, icon_name: str) -> Any:
 1343          """è·å–æ¶ˆæ¯æ¡†å›¾æ ‡æšä¸¾

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 28 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
 1344          
 1345          Args:
 1346              icon_name: 'NoIcon', 'Information', 'Warning', 'Critical', 'Question'
 1347          
 1348          Returns:
 1349              QMessageBox.Icon æšä¸¾å€¼
 1350          """
 1351          cls._ensure_qt_imported()
 1352          return getattr(cls._qt_widgets.QMessageBox.Icon, icon_name, cls._qt_widgets.QMessageBox.Icon.Information)
 1353      
 1354      @classmethod
 1355      def get_message_box_button(cls, button_name: str) -> Any:
 1356          """è·å–æ¶ˆæ¯æ¡†æŒ‰é’®æšä¸¾
 1357          
 1358          Args:
 1359              button_name: 'Yes', 'No', 'Ok', 'Cancel', ç­‰
 1360          
 1361          Returns:
 1362              QMessageBox.StandardButton æšä¸¾å€¼
 1363          """
 1364          cls._ensure_qt_imported()
 1365          return getattr(cls._qt_widgets.QMessageBox.StandardButton, button_name, cls._qt_widgets.QMessageBox.StandardButton.Ok)
 1366      
 1367      @classmethod
 1368      def get_tray_icon_type(cls, icon_name: str) -> Any:
 1369          """è·å–æ‰˜ç›˜å›¾æ ‡ç±»å‹æšä¸¾
 1370          
 1371          Args:
 1372              icon_name: 'NoIcon', 'Information', 'Warning', 'Critical'
 1373          
 1374          Returns:
 1375              QSystemTrayIcon.MessageIcon æšä¸¾å€¼
 1376          """
 1377          cls._ensure_qt_imported()
 1378          return getattr(cls._qt_widgets.QSystemTrayIcon.MessageIcon, icon_name, cls._qt_widgets.QSystemTrayIcon.MessageIcon.Information)
 1379      
 1380      @classmethod
 1381      def get_event_type(cls, type_name: str) -> Any:
 1382          """è·å–äº‹ä»¶ç±»å‹æšä¸¾
 1383          
 1384          Args:
 1385              type_name: 'WindowStateChange', 'Timer', ç­‰
 1386          
 1387          Returns:
 1388              QEvent.Type æšä¸¾å€¼
 1389          """
 1390          cls._ensure_qt_imported()
 1391          return getattr(cls._qt_core.QEvent.Type, type_name, cls._qt_core.QEvent.Type.None_)
 1392  
 1393  

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 29 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
 1394  # ============================================
 1395  # ä¾¿æ·è®¿é—®å˜é‡ï¼ˆå¸¸ç”¨æšä¸¾å€¼ï¼‰
 1396  # ============================================
 1397  
 1398  class MessageBoxIcons:
 1399      """æ¶ˆæ¯æ¡†å›¾æ ‡å¸¸é‡"""
 1400      @property
 1401      def Information(self) -> Any:
 1402          return QtEnumAccessor.get_message_box_icon('Information')
 1403      
 1404      @property
 1405      def Warning(self) -> Any:
 1406          return QtEnumAccessor.get_message_box_icon('Warning')
 1407      
 1408      @property
 1409      def Critical(self) -> Any:
 1410          return QtEnumAccessor.get_message_box_icon('Critical')
 1411      
 1412      @property
 1413      def Question(self) -> Any:
 1414          return QtEnumAccessor.get_message_box_icon('Question')
 1415  
 1416  
 1417  class MessageBoxButtons:
 1418      """æ¶ˆæ¯æ¡†æŒ‰é’®å¸¸é‡"""
 1419      @property
 1420      def Yes(self) -> Any:
 1421          return QtEnumAccessor.get_message_box_button('Yes')
 1422      
 1423      @property
 1424      def No(self) -> Any:
 1425          return QtEnumAccessor.get_message_box_button('No')
 1426      
 1427      @property
 1428      def Ok(self) -> Any:
 1429          return QtEnumAccessor.get_message_box_button('Ok')
 1430      
 1431      @property
 1432      def Cancel(self) -> Any:
 1433          return QtEnumAccessor.get_message_box_button('Cancel')
 1434  
 1435  
 1436  class TrayIcons:
 1437      """æ‰˜ç›˜å›¾æ ‡å¸¸é‡"""
 1438      @property
 1439      def Information(self) -> Any:
 1440          return QtEnumAccessor.get_tray_icon_type('Information')
 1441      
 1442      @property
 1443      def Warning(self) -> Any:

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…·è½¯ä»¶_V3.1.0 æºä»£ç                                  ç¬¬ 30 é¡µ / å…± 241 é¡µ
----------------------------------------------------------------------
 1444          return QtEnumAccessor.get_tray_icon_type('Warning')
 1445      
 1446      @property
 1447      def Critical(self) -> Any:
 1448          return QtEnumAccessor.get_tray_icon_type('Critical')
 1449  
 1450  
 1451  class EventTypes:
 1452      """äº‹ä»¶ç±»å‹å¸¸é‡"""
 1453      @property
 1454      def WindowStateChange(self) -> Any:
 1455          return QtEnumAccessor.get_event_type('WindowStateChange')
 1456  
 1457  
 1458  # åˆ›å»ºå•ä¾‹å®ä¾‹ä¾›å¯¼å…¥ä½¿ç”¨
 1459  MessageBoxIcon = MessageBoxIcons()
 1460  MessageBoxButton = MessageBoxButtons()
 1461  TrayIconType = TrayIcons()
 1462  EventType = EventTypes()
 1463  
       
       # ============================================================
       # æ–‡ä»¶: src\__init__.py
       # ============================================================
 1464  # -*- coding: utf-8 -*-
 1465  """
 1466  å›¾ç‰‡å¼‚æ­¥ä¸Šä¼ å·¥å…· - æ¨¡å—åŒ–æ¶æ„
 1467  
 1468  v3.0.1 - æ¨¡å—åŒ–æ¶æ„é‡æ„å®Œæˆï¼Œå¸ƒå±€ä¼˜åŒ–
 1469  
 1470  ç›®å½•ç»“æ„:
 1471  - src/
 1472    - main.py: ç¨‹åºä¸»å…¥å£
 1473    - config.py: é…ç½®ç®¡ç†
 1474    - core/: æ ¸å¿ƒåŠŸèƒ½æ¨¡å—
 1475      - utils.py: å·¥å…·å‡½æ•°
 1476      - permissions.py: æƒé™ç®¡ç†
 1477    - ui/: ç”¨æˆ·ç•Œé¢æ¨¡å—
 1478      - widgets.py: è‡ªå®šä¹‰æ§ä»¶
 1479      - main_window.py: ä¸»çª—å£
 1480    - workers/: åå°å·¥ä½œçº¿ç¨‹
 1481      - upload_worker.py: ä¸Šä¼ å·¥ä½œçº¿ç¨‹
 1482    - protocols/: åè®®æ¨¡å—
 1483      - ftp.py: FTP åè®®å®ç°
 1484  """
 1485  
 1486  __version__ = "3.0.2"
 1487  __author__ = "RelMoTong"
       
       # ============================================================

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
